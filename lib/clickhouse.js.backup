import { createClient } from '@clickhouse/client';
import { cookies } from 'next/headers';

let clickhouseClient = null;
let currentConfig = null;

/**
 * Get connection config from cookies
 */
export async function getConfigFromCookies() {
  try {
    const cookieStore = await cookies();
    const configCookie = cookieStore.get('clickhouse_config');

    if (!configCookie) {
      return null;
    }

    return JSON.parse(decodeURIComponent(configCookie.value));
  } catch (error) {
    console.error('Error reading config from cookies:', error);
    return null;
  }
}

/**
 * Get or initialize ClickHouse client from request cookies
 */
export async function getClientFromRequest() {
  // Try to get existing client
  if (clickhouseClient) {
    return clickhouseClient;
  }

  // Try to initialize from cookies
  const config = await getConfigFromCookies();
  if (config) {
    return initClickHouseClient(config);
  }

  throw new Error('ClickHouse client not initialized. Please connect first.');
}

/**
 * Initialize ClickHouse client
 */
export function initClickHouseClient(config) {
  currentConfig = config;
  clickhouseClient = createClient({
    url: config.url || config.host || 'http://localhost:8123',
    username: config.username || 'default',
    password: config.password || '',
    database: config.database || 'default',
    clickhouse_settings: {
      max_execution_time: 300,
      max_memory_usage: 10000000000,
    },
    request_timeout: 300000,
  });

  return clickhouseClient;
}

/**
 * Get existing ClickHouse client, or initialize from config if provided
 */
export function getClickHouseClient(config = null) {
  // If config is provided, reinitialize
  if (config) {
    return initClickHouseClient(config);
  }

  // If client exists, return it
  if (clickhouseClient) {
    return clickhouseClient;
  }

  // If we have a stored config, reinitialize
  if (currentConfig) {
    return initClickHouseClient(currentConfig);
  }

  throw new Error('ClickHouse client not initialized. Call initClickHouseClient first.');
}

/**
 * Test connection to ClickHouse
 */
export async function testConnection(config) {
  try {
    const client = createClient({
      url: config.url || config.host,
      username: config.username,
      password: config.password,
      database: config.database || 'default',
    });

    const result = await client.query({
      query: 'SELECT 1 as test',
      format: 'JSONEachRow',
    });

    await result.json();
    return { success: true, message: 'Connection successful' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

/**
 * Detect cluster configuration
 */
export async function detectClusterConfig(client) {
  try {
    const result = await client.query({
      query: `
        SELECT
          cluster,
          shard_num,
          replica_num,
          host_name,
          host_address,
          port
        FROM system.clusters
        ORDER BY cluster, shard_num, replica_num
      `,
      format: 'JSONEachRow',
    });

    const clusters = await result.json();

    // If we got results, it's OSS (not Cloud)
    if (clusters.length > 0) {
      const uniqueClusters = [...new Set(clusters.map(c => c.cluster))];
      const hasSharding = clusters.some(c => c.shard_num > 1);
      const hasReplicas = clusters.filter(c => c.cluster === uniqueClusters[0]).length > 1;

      return {
        isClustered: true,
        isCloud: false, // OSS with accessible system.clusters
        clusters: uniqueClusters,
        defaultCluster: uniqueClusters[0] || null,
        hasSharding,
        hasReplicas,
        nodes: clusters,
      };
    }

    // Empty result - single node OSS or restricted access
    return {
      isClustered: false,
      isCloud: false, // Could be single-node OSS
      clusters: [],
      defaultCluster: null,
      hasSharding: false,
      hasReplicas: false,
      nodes: [],
    };
  } catch (error) {
    // If system.clusters is not accessible, likely Cloud or restricted OSS
    console.log('Unable to detect cluster config:', error.message);
    return {
      isClustered: false,
      isCloud: true, // Assume Cloud if system.clusters not accessible
      clusters: [],
      defaultCluster: null,
      hasSharding: false,
      hasReplicas: false,
      nodes: [],
    };
  }
}

/**
 * Build cluster-aware query
 */
export function buildClusterQuery(baseQuery, table, clusterConfig) {
  if (!clusterConfig.isClustered || !clusterConfig.defaultCluster) {
    // Single node or ClickHouse Cloud
    return baseQuery.replace('{table}', table);
  }

  // ClickHouse OSS with cluster - use clusterAllReplicas
  const clusterFunc = `clusterAllReplicas('${clusterConfig.defaultCluster}', ${table})`;
  return baseQuery.replace('{table}', clusterFunc);
}

/**
 * Execute query with automatic retries
 */
export async function executeQuery(client, query, options = {}) {
  const maxRetries = options.maxRetries || 3;
  const retryDelay = options.retryDelay || 1000;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const result = await client.query({
        query,
        format: options.format || 'JSONEachRow',
        clickhouse_settings: options.settings || {},
      });

      return await result.json();
    } catch (error) {
      if (attempt === maxRetries - 1) {
        throw error;
      }

      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, retryDelay * (attempt + 1)));
    }
  }
}

/**
 * Get ClickHouse version
 */
let cachedVersion = null;

export async function getClickHouseVersion(client) {
  if (cachedVersion) {
    return cachedVersion;
  }

  try {
    const result = await client.query({
      query: 'SELECT version() as version',
      format: 'JSONEachRow',
    });

    const data = await result.json();
    const versionString = data[0]?.version || '0.0.0';

    // Parse version string (e.g., "20.3.4.11" or "21.8.0.1")
    const versionMatch = versionString.match(/^(\d+)\.(\d+)\.(\d+)/);
    if (versionMatch) {
      cachedVersion = {
        full: versionString,
        major: parseInt(versionMatch[1], 10),
        minor: parseInt(versionMatch[2], 10),
        patch: parseInt(versionMatch[3], 10),
      };
    } else {
      // Fallback to assume latest version if parsing fails
      cachedVersion = {
        full: versionString,
        major: 24,
        minor: 0,
        patch: 0,
      };
    }

    return cachedVersion;
  } catch (error) {
    console.error('Error detecting ClickHouse version:', error);
    // Return a safe default (assume older version to use compatible queries)
    cachedVersion = {
      full: 'unknown',
      major: 19,
      minor: 0,
      patch: 0,
    };
    return cachedVersion;
  }
}

/**
 * Check if a table/column exists
 */
export async function checkTableExists(client, database, table) {
  try {
    const result = await client.query({
      query: `SELECT 1 FROM system.tables WHERE database = '${database}' AND name = '${table}' LIMIT 1`,
      format: 'JSONEachRow',
    });
    const data = await result.json();
    return data.length > 0;
  } catch (error) {
    return false;
  }
}

export async function checkColumnExists(client, database, table, column) {
  try {
    const result = await client.query({
      query: `SELECT 1 FROM system.columns WHERE database = '${database}' AND table = '${table}' AND name = '${column}' LIMIT 1`,
      format: 'JSONEachRow',
    });
    const data = await result.json();
    return data.length > 0;
  } catch (error) {
    return false;
  }
}
